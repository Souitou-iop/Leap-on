<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Leap Orbit v4 - æ— é™å®‡å®™ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            color: white;
            z-index: 10;
        }
        #score {
            font-size: 80px;
            font-weight: 900;
            opacity: 0.3;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
            font-variant-numeric: tabular-nums;
        }
        #game-title {
            font-size: 28px;
            font-weight: bold;
            color: #00d2ff;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }
        #version-tag { font-size: 12px; color: #666; display:block; margin-bottom:10px;}
        #start-msg {
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 40px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }
        
        /* é“å…·æ  UI */
        #buff-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }
        .buff-row {
            display: flex;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 2px black;
        }
        .buff-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 5px currentColor;
        }
        /* ç®€å•çš„é«˜åº¦è®¡ */
        #altimeter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.5);
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="buff-container">
    <div id="ui-mega" class="buff-row" style="color:#ffd700">
        <div class="buff-dot" style="background:#ffd700"></div> å·¨åŒ–æ— æ•Œ
    </div>
    <div id="ui-slow" class="buff-row" style="color:#00ffff">
        <div class="buff-dot" style="background:#00ffff"></div> æ—¶ç©ºå‡é€Ÿ
    </div>
    <div id="ui-magnet" class="buff-row" style="color:#bf00ff">
        <div class="buff-dot" style="background:#bf00ff"></div> å¼ºåŠ›ç£é“
    </div>
</div>

<div id="ui-layer">
    <div id="score">0</div>
    <div id="start-msg">
        <div id="game-title">LEAP ORBIT</div>
        <span id="version-tag">v4.0 Infinite</span>
        <div>æŒ‰ä½è“„åŠ› / æ¾å¼€å›è½</div>
        <div style="font-size:12px; color:#aaa; margin-top:10px;">
            ğŸŸ å¼¹å°„ ğŸŸ¡å·¨åŒ– ğŸ”µå‡é€Ÿ ğŸŸ£ç£é“
        </div>
    </div>
</div>

<div id="altimeter">ALT: 0m</div>

<canvas id="gameCanvas"></canvas>

<script>
    const GAME_VERSION = "v4.0";
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const msgEl = document.getElementById('start-msg');
    const altEl = document.getElementById('altimeter');
    
    // UI Elements
    const uiMega = document.getElementById('ui-mega');
    const uiSlow = document.getElementById('ui-slow');
    const uiMagnet = document.getElementById('ui-magnet');

    let width, height, centerX, centerY;
    let frameId;
    let score = 0;
    let isGameOver = true;
    let isPressing = false;
    let cameraScale = 1; // æ‘„åƒæœºç¼©æ”¾æ¯”ä¾‹

    // æ¸¸æˆå…¨å±€é€Ÿåº¦ç³»æ•° (ç”¨äºå®ç°æ…¢åŠ¨ä½œ)
    let globalTimeScale = 1.0; 

    const player = {
        angle: 0,
        radius: 60,       
        baseRadius: 60,   
        
        // --- v4.0 ç‰©ç†æ‰‹æ„Ÿå¾®è°ƒ (æ›´é‡ã€æ›´ç¨³) ---
        rVelocity: 0,     
        accelOut: 0.6,    // é™ä½æ¨åŠ› (åŸ1.2 -> 0.6) å¢åŠ æ“ä½œç²¾åº¦
        gravity: 0.35,    // é™ä½é‡åŠ› (åŸ0.5 -> 0.35) é…åˆæ— é™é«˜åº¦
        drag: 0.96,       // å¢åŠ é˜»åŠ› (åŸ0.94 -> 0.96) é˜²æ­¢åˆ¹ä¸ä½è½¦
        rotSpeed: 0.035,
        // ------------------------------------

        baseSize: 14,
        size: 14,
        color: '#00d2ff',
        x: 0,
        y: 0,
        trail: [],
        
        // çŠ¶æ€è®¡æ—¶å™¨
        megaTime: 0,   // å·¨åŒ–
        slowTime: 0,   // å‡é€Ÿ
        magnetTime: 0, // ç£é“
        boostCoolDown: 0 // é˜²æ­¢è¿ç»­è§¦å‘ç²’å­
    };

    let entities = []; 
    let particles = []; 
    let shake = 0;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    function handleStart(e) { isPressing = true; if (isGameOver) restartGame(); }
    function handleEnd(e) { isPressing = false; }
    // ç»‘å®šäº‹ä»¶
    ['mousedown', 'touchstart'].forEach(evt => window.addEventListener(evt, handleStart, {passive: false}));
    ['mouseup', 'touchend'].forEach(evt => window.addEventListener(evt, handleEnd, {passive: false}));

    function randomRange(min, max) { return Math.random() * (max - min) + min; }

    // å®ä½“ç±»
    class Entity {
        constructor(type) {
            this.type = type; 
            this.angle = randomRange(0, Math.PI * 2);
            
            // --- åŠ¨æ€ç”Ÿæˆé€»è¾‘ ---
            // æ°¸è¿œç”Ÿæˆåœ¨ç©å®¶å½“å‰çš„ä¸Šæ–¹æˆ–é™„è¿‘ï¼Œè€Œä¸æ˜¯å›ºå®šçš„åŒºåŸŸ
            // è¿™æ ·æ— è®ºé£å¤šé«˜éƒ½èƒ½é‡åˆ°ä¸œè¥¿
            let spawnBase = Math.max(player.baseRadius + 100, player.radius);
            this.dist = randomRange(spawnBase + 50, spawnBase + 600);
            
            this.active = true;
            this.scale = 0;
            this.maxScale = 1;
            
            // å±æ€§é…ç½®
            switch(type) {
                case 'score': 
                    this.size = 10; this.color = '#fff'; break;
                case 'enemy': 
                    this.size = 18; this.color = '#000'; this.moveSpeed = randomRange(-0.005, 0.005); break;
                case 'boost': // å¼¹å°„ (æ©™è‰²)
                    this.size = 15; this.color = '#ff6600'; break;
                case 'mega':  // å·¨åŒ– (é‡‘è‰²)
                    this.size = 15; this.color = '#ffd700'; break;
                case 'slow':  // å‡é€Ÿ (é’è‰²)
                    this.size = 15; this.color = '#00ffff'; break;
                case 'magnet': // ç£é“ (ç´«è‰²)
                    this.size = 15; this.color = '#bf00ff'; break;
            }
        }

        update() {
            if (this.scale < this.maxScale) this.scale += 0.1;

            if (this.type === 'enemy') {
                // æ•Œäººçš„ç§»åŠ¨å—æ—¶é—´æµé€å½±å“ (æ…¢åŠ¨ä½œæ—¶å˜æ…¢)
                this.angle += this.moveSpeed * globalTimeScale;
            }

            // ç£é“é€»è¾‘
            if (this.type === 'score' && player.magnetTime > 0) {
                let dx = player.x - (centerX + Math.cos(this.angle) * this.dist);
                let dy = player.y - (centerY + Math.sin(this.angle) * this.dist);
                let distSq = dx*dx + dy*dy;
                
                // ç£é“èŒƒå›´éšä½“å‹å˜å¤§è€Œå˜å¤§
                let range = player.megaTime > 0 ? 90000 : 40000;
                
                if (distSq < range) { 
                    this.dist += (player.radius - this.dist) * 0.2 * globalTimeScale;
                    let diffAngle = player.angle - this.angle;
                    while (diffAngle > Math.PI) diffAngle -= Math.PI * 2;
                    while (diffAngle < -Math.PI) diffAngle += Math.PI * 2;
                    this.angle += diffAngle * 0.15 * globalTimeScale;
                    if(distSq < 2500) return true; // å¸å…¥
                }
            }
            return false;
        }

        draw(ctx) {
            if (!this.active) return;
            const x = centerX + Math.cos(this.angle) * this.dist;
            const y = centerY + Math.sin(this.angle) * this.dist;
            const s = this.size * this.scale;

            ctx.save();
            ctx.translate(x, y);

            if (this.type === 'enemy') {
                ctx.rotate(Date.now() / 500); // è‡ªè½¬
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // ç»˜åˆ¶æ›´å°–é”çš„åˆºçƒ
                for(let i=0; i<8; i++) {
                    let rot = Math.PI / 4 * i;
                    ctx.lineTo(Math.cos(rot)*s, Math.sin(rot)*s);
                    ctx.lineTo(Math.cos(rot + Math.PI/8)*(s*0.4), Math.sin(rot + Math.PI/8)*(s*0.4));
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#ff3333';
                ctx.lineWidth = 2;
                ctx.stroke();
            } else if (['boost', 'mega', 'slow', 'magnet'].includes(this.type)) {
                // é“å…·ç»˜åˆ¶ (å¸¦å…‰ç¯)
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(0,0, s, 0, Math.PI*2); ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0,0, s + 4 + Math.sin(Date.now()/200)*2, 0, Math.PI*2); ctx.stroke();
                
                // å†…éƒ¨å›¾æ ‡ (ç®€å•å­—æ¯)
                ctx.fillStyle = 'black';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let label = '';
                if(this.type==='boost') label='UP';
                if(this.type==='mega') label='BIG';
                if(this.type==='slow') label='TIME';
                if(this.type==='magnet') label='MAG';
                ctx.fillText(label, 0, 0);

            } else {
                // ç™½çƒ
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(0,0, s, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = "white"; ctx.fill(); ctx.shadowBlur = 0;
            }
            ctx.restore();
        }
        getPos() {
            return {
                x: centerX + Math.cos(this.angle) * this.dist,
                y: centerY + Math.sin(this.angle) * this.dist
            };
        }
    }

    class Particle {
        constructor(x, y, color, speed = 1) {
            this.x = x; this.y = y; this.color = color;
            this.vx = (Math.random() - 0.5) * 8 * speed;
            this.vy = (Math.random() - 0.5) * 8 * speed;
            this.life = 1.0;
        }
        update() {
            this.x += this.vx * globalTimeScale;
            this.y += this.vy * globalTimeScale;
            this.life -= 0.03 * globalTimeScale;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    // --- æ¸¸æˆé€»è¾‘æ ¸å¿ƒ ---

    function spawnEntity() {
        if (entities.length > 20) return; // ç¨å¾®å¢åŠ åŒå±ä¸Šé™
        
        let r = Math.random();
        
        // é“å…·ç”Ÿæˆæ¦‚ç‡ (æ€»å…±çº¦ 5%)
        if (r < 0.01) entities.push(new Entity('boost'));
        else if (r < 0.02) entities.push(new Entity('mega')); 
        else if (r < 0.03) entities.push(new Entity('slow'));
        else if (r < 0.045) entities.push(new Entity('magnet'));
        
        // æ•Œäººç”Ÿæˆ (æ ¹æ®åˆ†æ•°å¢åŠ éš¾åº¦)
        else if (r < 0.10) {
             let enemyCount = entities.filter(e => e.type === 'enemy').length;
             let maxEnemies = 3 + Math.floor(score / 15); 
             if (enemyCount < maxEnemies) entities.push(new Entity('enemy'));
        }
        // ç™½çƒ
        else if (r < 0.20) entities.push(new Entity('score'));
    }

    function restartGame() {
        score = 0;
        isGameOver = false;
        player.angle = 0;
        player.radius = player.baseRadius;
        player.rVelocity = 0;
        player.megaTime = 0;
        player.slowTime = 0;
        player.magnetTime = 0;
        entities = [];
        particles = [];
        scoreEl.innerText = score;
        msgEl.style.display = 'none';
        cameraScale = 1;
        loop();
    }

    function checkCollision(x1, y1, r1, x2, y2, r2) {
        let dx = x1 - x2;
        let dy = y1 - y2;
        return (dx*dx + dy*dy) < (r1+r2)*(r1+r2);
    }

    function createExplosion(x, y, color, size = 1) {
        for(let i=0; i<10 * size; i++) particles.push(new Particle(x, y, color, size));
    }

    function update() {
        if (isGameOver) return;

        // 1. å¤„ç† Buff æ—¶é—´ä¸çŠ¶æ€
        if (player.megaTime > 0) player.megaTime--;
        if (player.magnetTime > 0) player.magnetTime--;
        
        // æ…¢åŠ¨ä½œé€»è¾‘
        if (player.slowTime > 0) {
            player.slowTime--;
            globalTimeScale = 0.5; // æ—¶é—´æµé€Ÿå‡åŠ
        } else {
            globalTimeScale = 1.0;
        }

        // å·¨åŒ–é€»è¾‘ (å¹³æ»‘å˜å¤§å˜å°)
        let targetSize = (player.megaTime > 0) ? player.baseSize * 2.5 : player.baseSize;
        player.size += (targetSize - player.size) * 0.1;

        // UI æ›´æ–°
        uiMega.style.opacity = player.megaTime > 0 ? 1 : 0;
        uiSlow.style.opacity = player.slowTime > 0 ? 1 : 0;
        uiMagnet.style.opacity = player.magnetTime > 0 ? 1 : 0;

        // 2. ç©å®¶ç‰©ç† (æ ¸å¿ƒä¿®æ”¹)
        // æ—‹è½¬å—æ…¢åŠ¨ä½œå½±å“
        player.angle += player.rotSpeed * globalTimeScale;

        if (isPressing) {
            // å‘å¤–æ¨åŠ›
            player.rVelocity += player.accelOut * globalTimeScale;
        } else {
            // å‘å†…é‡åŠ›
            player.rVelocity -= player.gravity * globalTimeScale;
        }

        // é˜»åŠ›
        player.rVelocity *= player.drag;
        player.radius += player.rVelocity * globalTimeScale;

        // å†…åœˆåå¼¹
        if (player.radius < player.baseRadius) {
            player.radius = player.baseRadius;
            player.rVelocity = -player.rVelocity * 0.4; 
        }

        // è®¡ç®—åæ ‡
        player.x = centerX + Math.cos(player.angle) * player.radius;
        player.y = centerY + Math.sin(player.angle) * player.radius;

        // æ‹–å°¾
        player.trail.push({x: player.x, y: player.y});
        if (player.trail.length > 30) player.trail.shift();

        // 3. æ‘„åƒæœºç¼©æ”¾é€»è¾‘ (æ— é™é«˜åº¦çš„æ ¸å¿ƒ)
        // å½“åŠå¾„è¶…è¿‡ 250 æ—¶å¼€å§‹ç¼©å°ï¼Œæœ€å°ç¼©æ”¾åˆ° 0.3 å€
        let targetScale = 1;
        if (player.radius > 250) {
            targetScale = 450 / (player.radius + 200); 
        }
        // å¹³æ»‘æ‘„åƒæœº
        cameraScale += (targetScale - cameraScale) * 0.05;

        // æ›´æ–°é«˜åº¦è®¡ UI
        altEl.innerText = `ALT: ${Math.floor(player.radius - player.baseRadius)}m`;

        // 4. å®ä½“é€»è¾‘
        spawnEntity();

        // æ£€æŸ¥è¿‡è¿œçš„å®ä½“å¹¶ç§»é™¤ (ä¼˜åŒ–æ€§èƒ½)
        // åªæœ‰å½“å®ä½“ç¦»ä¸­å¿ƒå¤ªè¿œ ä¸” ç¦»ç©å®¶ä¹Ÿè¿œæ—¶æ‰ç§»é™¤
        for (let i = entities.length - 1; i >= 0; i--) {
            let e = entities[i];
            
            // å¦‚æœå®ä½“ç¦»åœ†å¿ƒè·ç¦» æ¯” ç©å®¶ç¦»åœ†å¿ƒè·ç¦» å¤§å¾ˆå¤šï¼Œæˆ–è€…å¤ªå°
            let diff = e.dist - player.radius;
            if (diff < -600 || diff > 1000) { // åŠ¨æ€æ¸…ç†èŒƒå›´
                entities.splice(i, 1);
                continue;
            }

            let sucked = e.update();
            let pos = e.getPos();

            // ç¢°æ’æ£€æµ‹
            if (checkCollision(player.x, player.y, player.size, pos.x, pos.y, e.size) || sucked) {
                // é€šç”¨æ¶ˆé™¤é€»è¾‘
                entities.splice(i, 1);

                if (e.type === 'score') {
                    score++;
                    scoreEl.innerText = score;
                    createExplosion(pos.x, pos.y, 'white');
                } 
                else if (e.type === 'boost') {
                    player.rVelocity += 25; // ç¬é—´åŠ é€Ÿ
                    createExplosion(pos.x, pos.y, '#ff6600', 2);
                    shake = 10;
                }
                else if (e.type === 'mega') {
                    player.megaTime = 600; // 10ç§’
                    createExplosion(pos.x, pos.y, '#ffd700', 2);
                    shake = 10;
                }
                else if (e.type === 'slow') {
                    player.slowTime = 400; // çº¦6-7ç§’
                    createExplosion(pos.x, pos.y, '#00ffff', 2);
                }
                else if (e.type === 'magnet') {
                    player.magnetTime = 600; 
                    createExplosion(pos.x, pos.y, '#bf00ff');
                }
                else if (e.type === 'enemy') {
                    // å·¨åŒ–æ¨¡å¼ä¸‹æ’ç¢æ•Œäºº
                    if (player.megaTime > 0) {
                        createExplosion(pos.x, pos.y, 'red', 1.5);
                        shake = 5;
                        score += 5;
                        scoreEl.innerText = score;
                    } else {
                        gameOver();
                        return;
                    }
                }
            }
        }

        // ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        if (shake > 0) shake *= 0.9;
        if (shake < 0.5) shake = 0;
    }

    function gameOver() {
        isGameOver = true;
        shake = 30;
        msgEl.style.display = 'block';
        msgEl.innerHTML = `<div id="game-title">GAME OVER</div><div>${score} åˆ†</div><div style="font-size:14px;color:#888;margin-top:5px">ç‚¹å‡»é‡è¯•</div>`;
        createExplosion(player.x, player.y, player.color, 2);
        draw();
    }

    function draw() {
        // 1. èƒŒæ™¯å¤„ç† (éšæ…¢åŠ¨ä½œå˜è‰²)
        if (player.slowTime > 0) {
            ctx.fillStyle = `rgba(0, 40, 40, 1)`; // æ…¢åŠ¨ä½œæ—¶èƒŒæ™¯åé’
        } else {
            ctx.fillStyle = '#1a1a1a';
        }
        ctx.fillRect(0, 0, width, height);

        // åº”ç”¨éœ‡åŠ¨
        let dx = (shake > 0) ? (Math.random() - 0.5) * shake : 0;
        let dy = (shake > 0) ? (Math.random() - 0.5) * shake : 0;

        // --- æ‘„åƒæœºå˜æ¢å¼€å§‹ ---
        ctx.save();
        ctx.translate(centerX + dx, centerY + dy);
        ctx.scale(cameraScale, cameraScale); // ç¼©æ”¾æ ¸å¿ƒ
        ctx.translate(-centerX, -centerY);

        // ç»˜åˆ¶ä¸­å¿ƒç‚¹
        ctx.beginPath();
        ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.stroke();

        // ç»˜åˆ¶å‡ åœˆå‚è€ƒçº¿ï¼Œå¢åŠ é€Ÿåº¦æ„Ÿå’Œæ·±åº¦æ„Ÿ
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.beginPath(); ctx.arc(centerX, centerY, 200, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(centerX, centerY, 500, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(centerX, centerY, 1000, 0, Math.PI*2); ctx.stroke();
        
        // å†…åœˆå®‰å…¨çº¿
        ctx.beginPath();
        ctx.arc(centerX, centerY, player.baseRadius, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.stroke();

        if (isGameOver && particles.length > 0) {
             particles.forEach(p => p.draw(ctx));
             ctx.restore();
             return;
        }

        // ç»³å­
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(player.x, player.y);
        ctx.strokeStyle = 'rgba(0, 210, 255, 0.15)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // æ‹–å°¾
        if (player.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(player.trail[0].x, player.trail[0].y);
            for (let i = 1; i < player.trail.length; i++) {
                ctx.lineTo(player.trail[i].x, player.trail[i].y);
            }
            ctx.strokeStyle = player.megaTime > 0 ? '#ffd700' : player.color;
            ctx.lineWidth = player.size;
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        // ç©å®¶ (å·¨åŒ–æ—¶æœ‰å…‰ç¯)
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.fillStyle = player.megaTime > 0 ? '#ffd700' : player.color;
        ctx.fill();
        
        // ç©å®¶å…‰æ™•
        if (player.megaTime > 0) {
            ctx.strokeStyle = `rgba(255, 215, 0, 0.5)`;
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(player.x, player.y, player.size + 5, 0, Math.PI*2); ctx.stroke();
        }
        if (player.slowTime > 0) {
             // æ…¢åŠ¨ä½œæ—¶èº«ä¸Šæœ‰æ®‹å½±
             ctx.fillStyle = `rgba(0, 255, 255, 0.2)`;
             ctx.beginPath(); ctx.arc(player.x - player.rVelocity*2, player.y, player.size, 0, Math.PI*2); ctx.fill();
        }

        // ç»˜åˆ¶å®ä½“
        entities.forEach(e => e.draw(ctx));
        particles.forEach(p => p.draw(ctx));

        // --- æ‘„åƒæœºå˜æ¢ç»“æŸ ---
        ctx.restore();
    }

    function loop() {
        update();
        draw();
        if (!isGameOver) frameId = requestAnimationFrame(loop);
    }

    // Start
    draw();

</script>
</body>
</html>
